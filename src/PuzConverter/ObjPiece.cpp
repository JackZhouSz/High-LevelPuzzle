///////////////////////////////////////////////////////////////
//
// ObjPiece.cpp
//
//   Piece OBJ Model Class
//
// by Peng Song  ( peng_song@sutd.edu.sg )
//
// 16/Jun/2021
//
///////////////////////////////////////////////////////////////


#include "Utility/HelpPuz.h"
#include "Puzzle/PieceFace.h"
#include "Puzzle/Piece.h"
#include "Face.h"
#include "Cube.h"
#include "ObjPiece.h"

#define VERTEX_OUT_LIST  -1


///=========================================================================================///
///                                     Initialization
///=========================================================================================///

ObjPiece::ObjPiece()
{
	cubeNum = 0;
	cubeList = NULL;
}

ObjPiece::~ObjPiece()
{
	if ( cubeList != NULL )
		delete [] cubeList;
}

void ObjPiece::InitPiece(int voxelNum)
{
	cubeNum = voxelNum;
	cubeList = new Cube[cubeNum];
}




///=========================================================================================///
///                                Compute Piece OBJ Model
///=========================================================================================///

void ObjPiece::ComputeOBJPiece(Piece *piece, float tolerance)
{
	for (int i=0; i<piece->voxelList.size(); i++)
	{
		float cubeSize = piece->voxelList[i]->size(X_INFO);
		float actualTolerance = tolerance * cubeSize;
		Vector3f cubeCenter = piece->voxelList[i]->center;

		cubeList[i].InitCube(actualTolerance, cubeSize, cubeCenter);
		cubeList[i].ComputeFaces();
		cubeList[i].ComputeEdges();
	}
}




///=========================================================================================///
///                               Save Piece OBJ Model
///=========================================================================================///

void ObjPiece::SavePieceOBJFile(char fileName[])
{
	vector<Quad> quadList = RemoveDuplicatedQuads();
	vector<Vector3f> pieceVertices = GetPieceVertices( quadList );
	vector<vector<int>> pieceQuads = GetPieceQuadrangles( quadList, pieceVertices );

	SaveOBJModel(pieceVertices, pieceQuads, fileName);
}

vector<Quad> ObjPiece::RemoveDuplicatedQuads()
{
	vector<Quad> origPieceQuads;
	vector<Quad> currPieceQuads;

	// Save all the quads for each deformed cube
	for (int i=0; i<cubeNum; i++)
	{
		vector<Quad> cubeQuads = cubeList[i].GetOutputQuads();

		for (int j=0; j<cubeQuads.size(); j++)
		{
			origPieceQuads.push_back( cubeQuads[j] );
		}
	}

	// Remove quads that appear more than once (i.e., quad not on the piece surface)
	for (int i=0; i<origPieceQuads.size(); i++)
	{
		if ( GetQuadNumInList(origPieceQuads[i], origPieceQuads ) == 1 )
		{
			currPieceQuads.push_back( origPieceQuads[i] );
		}
	}

	//printf("total Quad  before: %d   after: %d \n", origPieceQuads.size(), currPieceQuads.size());

	return currPieceQuads;
}


vector<Vector3f> ObjPiece::GetPieceVertices(vector<Quad> quadList)
{
	vector<Vector3f> pieceVertieces;

	for (int i=0; i<quadList.size(); i++)
	{
		for (int j=0; j<4; j++)
		{
			Vector3f cornerPoint = quadList[i].corners[j];

			if ( GetVertexIndexInList(cornerPoint, pieceVertieces) == VERTEX_OUT_LIST )
			{
				pieceVertieces.push_back( cornerPoint );
			}
		}
	}

	//printf("Vertex Num Before: %ld   After: %ld \n", 4*quadList.size(), pieceVertieces.size());

	return pieceVertieces;
}

vector<vector<int>> ObjPiece::GetPieceQuadrangles(vector<Quad> quadList, vector<Vector3f> pieceVertices)
{
	vector<vector<int>> pieceQuads;

	for (int i=0; i<quadList.size(); i++)
	{
		vector<int> pointIndices;

		for (int j=0; j<4; j++)
		{
			Vector3f cornerPoint = quadList[i].corners[j];
			int index = GetVertexIndexInList(cornerPoint, pieceVertices);

			if ( index >= 0 )
			{
				pointIndices.push_back( index );
			}
			else
			{
				pointIndices.push_back ( 0 );
				printf("Warning: The vertex index should be larger than zero. \n\n");
			}
		}

		pieceQuads.push_back( pointIndices );
	}

	return pieceQuads;
}


void ObjPiece::SaveOBJModel(vector<Vector3f> pieceVertices, vector<vector<int>> pieceQuads, char pieceFileName[])
{
	FILE *fp;
	if ((fp=fopen(pieceFileName,"w+"))==NULL)
	{
		printf("Error: file not exists! \n");	
		return;
	}
	else
	{
		////////////////////////////////////////////////////////
		// Write the vertex info of piece OBJ model

		fprintf(fp, "# Wavefront OBJ generated by Song Peng \n\n");

		fprintf(fp, "# %ld vertices \n", pieceVertices.size());

		for (int i=0; i<pieceVertices.size(); i++)
		{
			fprintf(fp, "v %f %f %f \n", pieceVertices[i](X_INFO), pieceVertices[i](Y_INFO), pieceVertices[i](Z_INFO));
		}
		fprintf(fp, "\n");

		////////////////////////////////////////////////////////
		// Write the quad info of piece OBJ model

		fprintf(fp, "# %ld faces (quadrangles) \n", pieceQuads.size());

		for (int i=0; i<pieceQuads.size(); i++)
		{
			//Since the index in OBJ file starting from 1 instead of 0, we need to add 1 to each index
#ifndef TRIANGLE_PIECE_OBJ
			fprintf(fp, "f %d %d %d %d \n", pieceQuads[i][0]+1, pieceQuads[i][1]+1, pieceQuads[i][2]+1,  pieceQuads[i][3]+1);
#else
            fprintf(fp, "f %d %d %d \n", pieceQuads[i][0]+1, pieceQuads[i][1]+1, pieceQuads[i][2]+1);
            fprintf(fp, "f %d %d %d \n", pieceQuads[i][0]+1, pieceQuads[i][2]+1, pieceQuads[i][3]+1);
#endif
		}
		fprintf(fp, "\n");

		fclose(fp); 
	}	
}


int ObjPiece::GetQuadNumInList(Quad testQuad, vector<Quad> quadList)
{
	// Note: this value depends on the model scale
	const float distThres = 0.00001; // For piece scale around: 10 mm 

	int quadNum = 0;
	for (int i=0; i<quadList.size(); i++)
	{
		float centerDist = (testQuad.center -  quadList[i].center).norm();
		//printf("dist: %.8f ", centerDist);
		if ( centerDist < distThres )
		{
			quadNum++;
		}
	}

	return quadNum;
}

int ObjPiece::GetVertexIndexInList(Vector3f testPoint, vector<Vector3f> vertexList)
{
	// Note: this value depends on the model scale
	const float distThres = 0.00001; // For piece scale around: 10 mm 

	for (int i=0; i<vertexList.size(); i++)
	{
		float centerDist = (testPoint - vertexList[i]).norm();
		if ( centerDist < distThres )
		{
			return i;
		}
	}

	return VERTEX_OUT_LIST;
}



